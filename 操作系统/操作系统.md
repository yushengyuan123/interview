# 操作系统内核

## 什么是OS内核

就是一些与硬件紧密相关的模块，各种各样的驱动程序和运行频率较高的模块，都安排在靠近硬件的软件层次中 ，将他们常驻内存，即通常称为os内核

## 什么是内核态和用户态

内核态又叫做系统态和管态，它具有较高的特权，能执行一切指令，访问所有寄存器和存储区，用户态，它是具有较低的特权执行状态，进能够执行规定指令，访问指令的寄存器和存储区

## 为什么要分为这两种状态

因为，为了防止os本身的关键数据遭受到应用程序的有意或者无意的修改

# 进程

## 处理机是什么

处理机：计算机系统中存储程序和数据，并按照规定的步骤执行指令的部件

## 进程有什么用

为了使程序能够并发执行，并且可以对并发的程序加以控制就引入了进程，进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

## 进程的创建

- 申请空白PCB
- 为新的进程分配其运行的所需资源
- 初始化PCB
- 如果进程就绪队列能够接纳新的进程，便将新的进程插入就绪队列

## 进程的定义

1. 进程是一次程序的依次执行
2. 进程是一个程序及其数据在处理机上顺序执行所发生的活动
3. 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配的和调度的一个单位

## PCB是什么

系统利用PCB描述进程的基本情况和活动过程，进而控制和管理进程

## 进程实体

程序段，相关数据和PCB够成进程实体

## 进程的特征

- 动态性：进程实质是进程实体的执行过程，它由创建而产生，调度而执行，撤销而消亡
- 并发性：多个进程实体在内存中，并且能够在一段时间内同时运行
- 独立性：不同进程实体独立获得资源，独立被调度，独立运行
- 异步性：不同的进程按照按照各自独立的，不可预知的向前执行，并发执行不可预知，但是并发的结果可以预知的

## 进程的状态

- 创建状态：进程是由创建产生的，创建过程是一个比较复杂的过程，如首先进程申请一个空白的PCB，并向PCB中填写了用于控制和管理进程的信息，然后为进程分配运行时的必须资源，最后进程变为就绪状态，进入到就绪队列中

  就绪：就绪状态就是进程获得了处cpu以外的资源，只要在获得cpu资源就能够马上执行，如果系统中有多个就绪的进程，那么它们就会排成一个队列，等待被调度

- 执行：进程获得了cpu的资源，其程序处于正在执行的状态

- 阻塞：当正在执行的进程由于发生了某一个事件，暂时无法继续执行时的状态，即进程收到了阻塞。

- 终止状态：等待操作系统善后处理，最后把pcb清零，把pcb空间归还给系统

## 挂起操作和进程状态转换

当该操作作用于某个线程的时候该进程将会被挂起，意味着此时该处于静止状态，如果进程正在执行，它将暂停执行，若原本就处于就绪状态就暂时不接受调度。 

## 状态的切换

创建，分配好资源和PCB后进入就绪状态进入就绪队列，当分配到了cpu的资源，进入运行状态，当遇到了某些事件时候可能会使的处于执行态的进程被暂停，进入阻塞状态。当一个进程分配给它的时间片已完成被剥夺处理机暂停执行的时候，就会回到就绪状态，当在阻塞状态的时候，那个事件完成了，进程又回到了就绪状态。

## PCB中的信息

- 进程控制符：标识一个进程
- 外部标识符：方便进程对于进程的访问
- 内部标识符：方便操作系统对进程的访问
- 处理机状态：它也叫做处理机的上下文，主要由处理机的各种寄存器的内容组成的。处理机在执行状态的时候，正在处理的许多信息都是放在寄存器中，当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便进程重新执行时能再从断点继续执行
- 进程调度信息：他有很多的信息，包括进程状态，进程的优先级，进程调度的其他信息，事件等等
- 进程的控制信息：包括程序和数据的地址，进程同步和通信机制，资源清单，连接指针（他给出了pcb队列中下一个pcb进程的首地址）

## PCB的组织方式

系统中有很多的PCB，那么你怎么把他们组织起来进行调度呢

- 线性方式，把表的首地址存放在一个区域，每次找的时候遍历，类似于数组一样，优点就是实现简单，缺点就是每次找到要进行全表扫描
- 链接方式，类似于链表一样，用指针，把具有相同状态的pcb链接在一起，形成一个队列，比如阻塞的放在一起，形成阻塞队列，就绪队列等等
- 索引：就建立几张索引表，索引表的记录着某个PCB在内存中地址，典型空间换时间例子

## 进程同步问题的解决方式

- 硬件解决方式：ts，关中断，swap
- 信号量的解决方式，整形信号量，记录型信号量，and型信号量

## 进程的同步问题

对进程的执行次序进行协调，使并发执行的诸进程按照一定的规则访问资源。对临界资源管理的时候，可以用锁的机制

## 同步机制应该遵循的原则

- 空闲让进
- 忙则等待：当临界资源正在被访问的时候，其他试图进入临界区的进程必须等待，保证对临界资源的有序访问
- 有限等待，对要求访问临界资源的进程，应保证在有限时间内进入自己的临界区，以避免死等状态
- 让权等待，当进程不能进入自己的临界区的时候，应立即释放出处理机，以免陷入忙等的状态

## 硬件的同步机制

- 关中断，关中断是实现互斥的最简单方式，在进入锁测试之前关闭中断，直到完成锁测试之后才能打开中断，这样就能够进程在临界区执行的时候，计算机就不会响应中断，不会引发调度，也不会发生进程切换，保证了对锁的测试和关锁操作的连续性和完成性

- test-and-set指令实现互斥，它是一条硬件指令，这个ts指令管理临界资源的时候，为每一个临界资源设置一个布尔值lock，由于变量lock表示了该资源的状态，可以把他表示为一个锁，他表示为函数

  ```
  function ts () {
  	boolean old
  	old = *lock
  	*lock = true
  	return old
  }
  ```

  当进程进入临界区的时候，为每先用ts指令测试一下lock，如果为false，表示没有进程访问，那么可以进入并且把lock设置为true，此时就没有进程能够访问进来。

- swap指令实现互斥，每个资源都有一个全局的lock，每个进程中再利用一个局部布尔变量key = true，swap开启一个循环，尝试把资源的key交换进入临界资源的loack中，当交换成功就停止循环，交互不成功就一直进行尝试交换，它符合了忙则等待，但是一直循环造成了处理机时间的浪费

## 信号量机制解决进程同步问题

### 信号量的类型

- 整形信号量，通过某个信号量定义资源数目的整形量S，我们只能够通过两个原语操作，成为PV操作来改变信号量，signal释放资源，wait就是请求资源，
- 记录型信号量，在整形信号量机制中，只要是信号量<=0，就会不断测试，那么他是不符合一个让权等待的原则，那么记录信号量为了解决这个，**不仅需要一个整形的信号量，同时还需要一个进程链表指针**，用于链接所有等待的进程。当某一类资源已经使用完了，整形信号量<0的时候，**进程应该主动调用block原语，放弃处理机**，并插入到信号量链表中中，当有资源释放出来了，那么就是调用wakeup原语从链表中唤醒进程
- and型信号量，

### 信号量的应用

- 利用信号量实现互斥
- 利用信号量实现前驱关系
- 这里有待后续再看



## 进程的通信

- 共享存储器系统，在共享存储器系统中，互相通信的进程共享某些数据结构或者共享存储区，进程之间能够通过这些空间进行通信。那么又可以把这种通信方式分为两种，基于共享数据结构的通信方式和基于共享存储区的通信方式
- 管道通信机制，在js的流中是有这个方法的，它可以连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件，向管道提供输入的发送进程以字符流形式将大量的数据送入管道，而接受管道的输出的接收进程则从管道中接收数据，为了协调双方的通信，管道机制必须提供以下三方面的协调能力：**互斥**，一个再写/读，另外一个必须等待，**同步**，当写入一定数量的数据到pipe中，写进程就去睡眠等待，等待读进程读完了之后再去写；**确定对方是否存在**
- 消息传递系统，进程不必借助任何共享存储区域或数据结构，而是以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令在进程之间进行通信
- 客户机-服务器系统，socket

## 匿名管道和命名管道区别

匿名管道：

- 只提供单向通信，也就是说两个进程都能够访问这个文件，一个向里面写入，另外一个只能够读出
- 只能用于具有亲缘关系的进程通信，用于父子进程建通信
- 管道依赖字节赖通通信
- 依赖文件系统，它的声明周期随进程的结束结束

通信步骤：

- 调用pipe函数，有父进程创建管道，得到两个文件描述符指向管道两端
- 父进程调用fork创建子进程，子进程也有两个文件描述符指向管道的两端
- 父进程关闭读端，只进行写操作，子进程关闭写端，只进行读端

命名管道：

- 与匿名管道区别：提供了一个路径名与之相关，以FIFI文件的形式存储与文件系统，实现两个进程的通信，匿名管道对于文件系统时不可见的
- fifo是一个设备文件，在文件系统以文件名的形式存在，因此即使不相关的进程也可以通信
- fifo文件遵循先进先出的原则，第一个进来的数据会被读走





## 基于共享数据结构的通信方式

这种通信方式要求进程公用某些数据结构，借以实现诸进程的信息交换，由程序员负责对公用数据结构进行设置以及对进程间的通过同步处理，这种通信仅适用于传递相对少量的数据，通信效率低下

## 基于共享区域的通信方式

为了方便大量数据的传输，诸进程可以对该共享区域进行读或者写，从而来实现通信







# 线程

## 为什么需要线程

传统的操作系统中，进程作为拥有资源和独立调度运行的单位，对于一个线程的创建，销毁和切换都是一些比较重量级的操作，那么后来就引入了线程，为了减少程序在并发执行时所付出的时空开销

## 进程的并发开销体现

创建：系统在创建一个进程时，必须为他分配内存，处理机和其他资源，pcb等

销毁的时候：就需要把创建的东西全部都回收

切换的时候：需要保存当前进程的cpu环境，设置新选中的进程的cpu环境十分麻烦

## 如何减少并发调度的开销

为了进程的创建，销毁，切换消耗因为进程本上携带的信息太多了，那么优化就可以从这个角度去入手：

- 不要把作为调度和分派的基本单位也同时作为拥有资源的单位，那么我们可以想办法把这个两个东西区分开，做到轻装上阵
- 拥有资源的单位，我们不要随便对他进行频繁的切换

## 线程运行的三个状态

- 执行态：表示线程已经获得了处理机而正在运行
- 就绪状态：表示线程已经具有各种执行条件，只需在获得CPU便可以立即执行
- 阻塞状态：指线程由于某事件受阻而处于暂停状态

## 线程有哪两种

- 内核级线程，这些线程的创建，阻塞，撤销和切换等，都是在内核空间实现，可以很好的利用cpu，一个内核线程阻塞不会导致其他线程阻塞。
- 用户级线程，不需要内核支持而在用户程序中实现的线程，不依赖于操作系统核心，它通过线程库创建，同步，调度和管理线程的函数来控制用户线程。操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程阻塞

区别：

- 内核线程是os内核可感知的，用户级线程是os内核不可感知
- 用户级创建的线程，调度，撤销是语言这一级处理的，内核支持的线程的创建时os内核提供支持
- 用户级线程执行系统调用执行将导致其所属进程被中断，内核线程被阻塞的时候执导之该线程被中断
- 在用户级现成的系统内，cpu调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程轮换运行，在内核支持现成的系统内，cpu调度则以进程为单位，由os的线程调度的程序负责线程调度

内核线程优点：线程调度不需要



# 进程和线程的比较

- 调度的基本单位，传统os中，进程作为独立调度和分派的基本单位，因为进程是能独立运行的基本单位，在每次被调度时，需要进行上下文的切换，开销大。引入线程的os把线程作为调度和分派的基本单位，因而线程也能够独立运行，线程切换时只需要保存和设置少量寄存器内容，代价远小于进程，同一个进程，线程的内部切换不会引起进程切换，但从一个进程切换到另外一个进程，就会引起进程的切换
- 并发性：进程可以并发，线程也可以并发。
- 拥有资源：进程可以拥有资源，并作为系统中拥有资源的一个基本单位，但是，线程本身不拥有资源，而是仅有一点必不可少的。能够保证独立运行的资源。例如，每个线程需要有一个控制线程运行的控制块TCB。虽然线程只能够拥有少量资源，但是它可以共享进程的资源
- 独立性：统一进程里面的线程的独立性比起不同进程之间的独立性要低得多，进程为了防止互相破坏，那么就需要都拥有一个独立的地址空间和其他资源，除了共享全局变量外，不允许其他进程的访问。同一进程的不同线程往往为了提高并发性以及进行互相合作而创建的，它们共享的内存地址空间和资源，每个线程都可以访问它们所属进程地址空间中的所有地址，如一个线程的堆栈可以被其他线程去读，甚至清除
- 系统开销，进程的创建或者销毁，操作系统都要给他分配内存，pcb，销毁的时候回收内存，回收pcb，每次这种操作都需要付出开销，明显大于线程的创建付出的开销。类似的进程切换的时候，涉及到进程上下文的切换，进程上下文切换比线程开销大得多。此外一个进程中的多个线程具有相同的地址空间，线程之间的同步通信也比进程简单。

总结：

- 从产生关系来说：进程产生线程
- 从资源的拥有角度的来说：线程只拥有很少的资源，做到轻装上阵，线程可以共享进程所拥有的资源。进程作为拥有资源的基本单位，但是为什么要这么做？聊下为什么需要线程，优化进程开销的一个设计思想
- 并发性：进程和线程都可以并发，但是进程拥有的资源大，在并发的时候，如果有一些切换操作
- 从资源的独立性角度来说：进程之间的为了互不影响，独立资源的拥有是独立的，统一进程下的不同线程，共享进程的内存地址空间和资源，每个线程都可以访问进程的资源，每一个线程的堆栈都可以被其他线程读写
- 系统开销，进程的创建，撤销和切换都是一些重量级的操作，线程之间的哪些操作开销小很多，因为进程里面不会携带过多的信息，同一个进程中的多个线程具有相同的地址空间，那么他们的那些通信开销小很多



# 死锁需要具备的条件

- 互斥条件 线程要求对所有的分配的资源进行排他性控制，某个资源某一段时间内仅为一个线程所占有
- 不剥夺条件：线程所获得的资源在未使用完毕之前，不能被其他线程夺走
- 请求和保持条件：线程已经保持了至少一个资源，但又提出了新的资源请求，而资源已被其他资源占用，导致请求阻塞，但是他对已获得的资源保持不妨
- 循环等待条件：存在一个循环等待链，链中的每一个线程同时被链中下一个线程所请求，最后就阻塞了

# 如何解决线程死锁

- 加锁时限
- 加锁顺序





# 作业调度

## 处理机调度层次

- 高级调度：又叫做长程调度或作业调度，**他调度的对象是作业**，其主要功能是根据某种算法，**决定将外存上处于后背队列中的哪几个作业调入内存，为他们创建进程，分配必要的资源**，并将他们放入就绪队列，
- 低级调度：又称为进程调度或者短程调度，其所调度的对象是进程，**或者说它根据某种算法决定就绪队列中的哪一个进程获得处理机**，并由分派程序将处理机分配给选中进程
- 中级调度：内存调度，它是把那些暂时不能运行的进程，调至外存等待，此时进程的状态称为就绪

进程调度即低级调度的运行频率最高，10-100ms便进行一次进程调度

## 批处理系统一些概念

周转时间，是指作业被提交给系统开始，到作业完成为止的这段时间间隔

它包括四部分时间：

- 作业在外存后备队列上等待调度的时间，
- 进程在就绪队列上等待进程的调度，
- 进程在cpu上执行的时间
- 以及进程等待I/O操作完成时间。

平均周转时间：公式就是对n个进程的周转时间求和 / n

带权周转时间：计算方式就是对于n进程...

作业：作业比程序更广泛的概念，不仅包含了通常的程序和数据，而且还应配一份作业说明书，系统根据这个说明书进行控制，批处理系统中，是以作业为基本单位从外存调入内存的

## 作业控制块JCB

为了管理和调度作业，多道批处理系统中为每一个作业设置了作业控制块JCB，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。

## 作业调度调度的是什么

作业调度主要任务就是根据JCB的信息，检查系统中的系统资源是否满足作业对资源的需求，以及按照一定的算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程，分配必要的资源

## 先来先服务调度算法FCFS

这个算法既可以用于作业调度，也可以用于进程调度。

算法核心：按照先来后到的形式进行调度或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需要执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，调入内存，为他们分配资源和创建进程

## 短作业优先SJF算法

它可以用与作业调度和进程调度

对于这种算法来说，作业越短优先级越高，这个长短指的是运行时间的长短。

算法的缺点：

- 必须预知时间
- 对长作业不利，可能会导致长作业的一个饿死
- 算法没有考虑作业的紧迫程度

## 优先级调度算法

他可以作为作业调度算法，也可以作为进程的调度算法

这种调度算法，是基于作业的紧迫程度，由外部赋予优先级，调度算法是根据优先级进行调度。

## 高响应比优先调度算法

高响应比优先调度算法则是既考虑了等待时间，有考虑了作业运行时间的调度算法，照顾了短作业，又不至是长作业等待时间过长。

实现原理：为每一个作业引入一个动态优先级，计算如下：

优先权 = (等待时间 + 要求服务时间) / 要求服务器时间，那么对于等待时间长的他的优先级就会越来越高，那么就有机会获得处理机

# 进程调度

## 进程调度的任务

- 保存处理记的现场信息
- 按某种算法选取进程
- 把处理器分配给进程



## 进程调度的方式

1. 非抢占式：一旦处理机分配给进程之后就让他以运行下去，不会因为时钟中断或任何其他原因去抢占当前正在运行进程的处理机，直至进程退出

2. 抢占方式：这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已经分配该进程的处理机重新分配给另外一个进程。

   抢占的原则有：

   - 优先权原则，优先级高的进程去抢占抢占当前的进程处理机
   - 短进程优先原则，新到的短进程比正在运行的进程明显短时，将处理机分配给新的短进程
   - 时间片原则，各进程按照时间片运行，当正在执行的进程的一个时间片用完了，就要停止进程的执行，重新去进行调度



## 轮转调度算法

轮转调度算法是基于时间片的轮转，

实现原理：所有的进程排成一个就绪队列，每隔一定的时间产生一次中断，重新激活调度程度，原来正在执行的进程就会被停止进入队尾，调度程序从对头取出进程来执行。

- 对于那些一个时间片无法完成的进程，那就就放入队尾，等待下次被去除来执行
- 对于那些一个时间片就能够完成的那么就会新开一个时间片给下一个进程

对于时间片选择的考虑：

- 假如说时间片选择得很小，那么就会造成进程的频繁切换，线程切换的开销是很大的。
- 假如说选择得很长，那么这个轮转算法就会退化成为先来先服务，不太好

## 优先级调度算法

优先级调度算法就是把处理机分配给优先级最高的进程。优先级算法又分为下面两种：

- 抢占式的优先级调度算法：就是当某个进程获得处理机，当由于某种事件，他可能会被中断，把处理机交给别的进程
- 非抢占式的优先级调度算法：就是当某个进程获得处理机，那么就不会被中断，一直到他执行结束

确定优先级的因素：

- 进程的类型：通常系统进程高于一般的用户进程
- 进程对资源的需求，对资源要求少的给更高的优先级（为什么？）
- 用户要求，根据进程的紧迫程度以及用户所付费用确定优先级

优先级的类型：

- 静态优先级，就是在进程创建的时候就赋值一个优先级，调度的时候一直都是这个优先级不会发生改变。但是这种东西就会有缺陷，就是一些优先级低的，等待的时间就会很长，可能有一种饿死现象。
- 动态优先级，就是这个优先级根据某个公式算出来的，其中可能含有等待时间作为计算的因素，那么这样就能够防止一些等待时间长的进程饿死。

## 多队列调度算法

在别的一些进程调度算法，例如优先级调度算法，轮转调度算法等等，它们都只设置一个就绪队列，因为只有一个队列，那么你的调度算法是固定的，无法满足系统不同用户对进程调度策略的不同要求。

那么为了解决这个问题，采用一种多队列的机制，不同类型的进程放在不同的队列中，不同的队列采用不同的调度算法。

## 多级反馈队列调度算法

上面的一些算法，什么优先级等这些进程调度算法，都需要知道进程的执行时间，那么这个多级反馈队列调度算法就不需要知道这个执行的时间

原理就是，有多个就绪队列，但是对于不同的队列他所能够分配给进程的时间片是不一样的，在前面的时间片长，后面是前面的两倍一次类推

当任务进来的时候，会被插入到第一个队列中，当一个进程能够在规定时间内完成就可以撤离，但完不成，就需要到第二个队列的末尾一次类推，第i个队列能够执行的因素是前1至i - 1个队列队列要是空闲的，假如说在执行某个进程的时候，有一个进程进入到了比他所队列的优先级更高的队列，那么这个进程需要中断，去执行那个优先级更高的进程。

当执行到最后一个队列的时候采用的是RR调度算法





# 死锁

## 资源的种类

- 可抢占性资源：这种资源是当进程获得这类资源后，该资源可以被其他进程或系统抢占，这类资源因为可以抢占，那么他们是不会发生死锁的
- 不可抢占性资源：某类进程获得这类资源之后，就不能够把它们强型回收，只能在进程用完后自行释放
- 可重用性资源：它是一种可供给用户重复使用的资源，他有一些特点：资源的数目是固定的，进程不能够销毁它和创建它；每一个可重用资源，不允许多个进程共享；进程获得资源需要按照一定的步骤，请求资源，进程会被阻塞，使用资源，释放资源
- 可消耗性资源：又称为临时资源，它是在运行期间由进程动态的创建和销毁

## 死锁的原因

死锁的起因是因为多个进程对资源的争夺，

- 对不可抢占资源进行争夺会死锁：假如说两个进程p1，p2，对两个文件f1，f2进行读写操作，两个文件不能同时读或者同时写，那么假如说p1正在打开f1，p2正在打开f2，同时p1需要打开f2去，p2又尝试去打开f1，那么就会产生死锁
- 对于可消耗的资源争夺也会死锁：这里有一个循环的场景，某一些进程，需要从别的进程读如数据，然后写另外的进程发送数据，那么假说说开始写读而不是先产生，由于开始的时候所有人都在等待读，那么就会产生死锁
- 进程推进顺序不当引起死锁 ：





## 死锁产生的必要条件

- 互斥条件：某一段时间内，某个资源只能够被一个进程占用，如果此时还有其他进程请求资源，别的进程只能够等待
- 不可抢占条件：进程已获得的资源再没使用完情况下不能够被抢占，只能等待进程自己释放
- 请求和保持条件：进程有了一个资源，但又提出了新的请求，但是请求的资源已经被别人所占用（不可抢占条件），根据互斥条件，它只能够阻塞等待，那么它此时又对自己的资源不放，就影响到了别人
- 循环等待：发生死锁的时候，比然存在一条资源的循环链，进程集合p0等待被p1占用的资源，然后p1...形成循环

## 处理死锁的办法

方法可以归结为四大类

- 预防死锁：
- 避免死锁
- 检测死锁
- 解除死锁

## 如何预防死锁



## 如何避免死锁

### 什么是安全状态和不安全状态

安全状态：就找某一个资源分配的序列，能够按照这种资源分配的顺序为每个资源分配资源，使得每个进程都能够满足他们的最大需求，使得每个进程都可以顺利的完成

不安全状态：就是你的资源分配顺序可能无法满足到某个进程的最大需求，那么这个时候就有可能会产生死锁

### 银行家算法避免死锁

银行家算法的执行思想：利用了安全状态和不安全状态的理论，对每一次资源的分配都进行一次安全性检测

需要的数据结构：

- 可用资源资源向量：代表每一个种资源的数目
- 最大需求矩阵：二维向量，代表不同的进程需要的不同资源需求数量的最大
- 分配矩阵：二维向量，代表某个进程已经分配了的资源数目
- 需求矩阵：二维向量，出去当前

算法流程：

- request，进程资源对某几类发出资源请求向量，数值表示请求的数目
- 判断如果request，request < need最大需求向量，那么报错，因为它已经超过了最大的请求之
- 如果没有超过request，那么判断request  <= avaible，当前资源可用向量，如果超过了，说明分配不了，进入不安全状态，不允许分配
- 如果没有超过，那么尝试把它分配给进程，然后修改对应数据结构的值
- 然后开始进行安全性检查

安全性检查流程：

- 设置工作向量work，他表示系统可提供给进程继续运行所需的各类资源数目，finish，表示系统是否有足够的资源分配给进程，让他完成工作，可以的话就标记为true，默认开始全都标记为false
- 从进程中找一个一个集合，它的finish[i]为false表示没有尝试对他进行资源分配的检测，找到之后，尝试对他进行资源分配，然后判断当前的需求量 <= work，是的话说明可以分配那么，就对他进行分配，修改对应的数据结构，重复上述步骤。
- 总之你最后要找到一种资源的分配顺序，能够安全的把所有的进程的资源都分配完毕，那么就知道你这次的分配是安全的，允许分配资源



## 如何检测死锁

资源分配图：

用一些符合代表进程和资源，如果某个进程对于资源的请求就用那个进程指向资源，如果某个进程需要获取资源，那么就用资源指向进程。

死锁定理：从某一个非阻塞又非独立的进程开始让他获取资源顺利执行，获取到了消除对应的边，最后如果所有的边都能够消除，表明图是可简化的，否则是不可简化的

死锁的充分条件是：状态资源分配图是不可完全化简的。

## 如何解除死锁

- 抢占资源：从一个或多个进程中抢占足够数量的资源，分配给死锁的进程，以解除死锁状态
- 终止进程：终止系统中一个或多个死锁的进程，直至打破循环环路，把系统从死锁中解除出来



